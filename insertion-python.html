<!doctype html>
<html>
    <head>
        <title>Rearrange the algorithms</title>
        <link href="./parsons.css" rel="stylesheet" />
        <link href="./lib/prettify.css" rel="stylesheet" />
        <script src="./lib/prettify.js"></script>
    </head>
    <body>
        <h2>Insertion sort in Python</h2>
        <p>Drag and drop the lines into the box on the right. The constructed function should grow the sorted list by one item each iteration. Unlike bubble sort, after the first pass, insertion sort has 'seen' two items, rather than all of them.</p>
        
        <p>Indentation matters, and there <em>may</em> be a line / lines that you shouldn't include.</p>
          
        <div id="sortableTrash" class="sortable-code"></div>
        <div id="sortable" class="sortable-code">
        </div>
        <div style="clear:both;"></div>
        <p>
            <button class='restart' href="#" id="newInstanceLink">Start again</button>
            <button class='submit' href="#" id="feedbackLink">Check my answer</button>
        </p>
        <script src="./lib/jquery.min.js"></script>
        <script src="./lib/jquery-ui.min.js"></script>
        <script src="./lib/jquery.ui.touch-punch.min.js"></script>
        <script src="./lib/underscore-min.js"></script>
        <script src="./lib/lis.js"></script>
        <script src="./parsons.js"></script>
        <script>
            var initial = 'def insertionSort(items)\n'+
        '  # start by inserting the second item into the sorted list and repeat for the others..\n'+
        '  for index in range(1,len(items))\n'+
        '    current_item = items[index]\n'+
        '    new_position = index\n'+
        '    # loop until the correct position for the current_item is found...\n'+
        '    while (new_position > 0) and (items[new_position -1] > current_item)\n'+
        '      # shift item right that is bigger than current_item..\n'+
        '      items[new_position] = items[new_position -1]\n'+
        '      # get ready to look at the next position..\n'+
        '      new_position = new_position -1\n'+
        '      new_position = new_position +1#distractor\n'+
        '    # once we get here, we have found the correct new position to put the current_item into\n'+
        '    items[new_position] = current_item\n';

        function displayErrors(fb) {
            if(fb.errors.length > 0) {
                alert(fb.errors[0]);
            }
        } 

        $(document).ready(function(){
            var parson = new ParsonsWidget({
                'sortableId': 'sortable',
                'trashId': 'sortableTrash',
                'max_wrong_lines': 2,
                'feedback_cb' : displayErrors
            });
            parson.init(initial);
            parson.shuffleLines();
            $("#newInstanceLink").click(function(event){
                event.preventDefault();
                parson.shuffleLines();
            });
            $("#feedbackLink").click(function(event){
                event.preventDefault();
                parson.getFeedback();
            });
        });        
        </script>
        <footer><a href="index.html" >Take me back to the algorithms...</a></footer>
    </body>
</html>
